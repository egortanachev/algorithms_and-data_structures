## Лабораторная работа №4

### Задание 1

Заполните массив 500 простыми числами, написанными слитно. Используя каждый изученный алгоритм поиска подстрок (наивный, Рабина-Карпа, Бойера-Мура, Кнута-Морриса-Пратта), посчитайте количество наиболее часто встречающихся двузначных чисел в образовавшейся строке. Сравните изученные алгоритмы поиска подстрок. Сделайте вывод о их достоинствах и недостатках.

#### Создание массива из 500 простых чисел

```
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0:
            return False
    return True

primes = []
n = 2
while len(primes) < 500:
    if is_prime(n):
        primes.append(n)
    n += 1

prime_string = ''.join(map(str, primes))
```

> Описание

#### Наивный алгоритм

```
def find_most_common(prime_string):
    count = {}
    for i in range(len(prime_string) - 1):
        num = int(prime_string[i:i+2])
        if num not in count:
            count[num] = 0
        count[num] += 1

    max_count = max(count.values())
    most_common = [num for num in count if count[num] == max_count]

    return {"most_common": most_common, "count": count}

result = find_most_common(prime_string)

print("Наиболее часто встречающиеся двузначные числа:")
for num in result["most_common"]:
    print(num, "встречается", result["count"][num], "раза")
```

> Описание

#### Алгоритм Рабина-Карпа

```
Код
```

> Описание

#### Алгоритм Бойера-Мура

```
Код
```

> Описание

#### Алгоритм Кнута-Морриса-Пратта

```
Код
```

> Описание

### Сравнение алгоритмов

Сравнение алгоритмов для поиска подстрок (наивный, Рабина-Карпа, Бойера-Мура, Кнута-Морриса-Пратта)

#### Наивный алгоритм

Самый простой способ поиска подстроки в строке. Он основан на сравнении каждого символа подстроки с символами строки в последовательном порядке. Если символы совпадают, алгоритм переходит к следующему символу подстроки, иначе он переходит к следующему символу в строке. Алгоритм продолжает этот процесс до тех пор, пока не будет найдено полное совпадение подстроки.

###### Достоинства:

* Простота и легкость реализации
* Хорошо работает на коротких строках и подстроках

###### Недостатки:

* Низкая производительность на длинных строках и подстроках, так как количество сравнений символов может быть очень большим
* Асимптотическая сложность $O(n \cdot m)$, где $n$ - длина строки, $m$ - длина подстроки

#### Алгоритм Рабина-Карпа

Алгоритм Рабина-Карпа использует хеширование для поиска подстроки в строке. Алгоритм вычисляет хеш-функцию для подстроки и сравнивает ее с хеш-функцией каждого фрагмента строки. Если хеш-функции совпадают, алгоритм проверяет полное совпадение символов. Если совпадение не найдено, алгоритм переходит к следующему фрагменту строки и снова вычисляет хеш-функцию.

###### Достоинства:

* Эффективность алгоритма не зависит от расположения подстроки в строке
* Основан на быстром вычислении хеш-функций, что ускоряет поиск
* Сложность алгоритма в худшем случае $O(n+m)$, где $n$ - длина строки, $m$ - длина подстроки

###### Недостатки:

* Возможны коллизии в хеш-функциях, что может привести к ложным совпадениям
* Дополнительная сложность при вычислении хеш-функции

#### Алгоритм Бойера-Мура

Алгоритм Бойера-Мура основан на использовании двух таблиц: таблицы суффиксов и таблицы смещений. Таблица суффиксов содержит информацию о правильных суффиксах подстроки, а таблица смещений содержит информацию о максимальном смещении для каждого символа в подстроке. Алгоритм начинает сравнение с конца подстроки и строки, и если символы не совпадают, он использует таблицу смещений для определения максимально возможного смещения и переходит на него. Если совпадение не найдено, алгоритм сдвигает подстроку на максимально возможное смещение и повторяет процесс.

###### Достоинства:

* Эффективен на длинных строках и подстроках
* Использует таблицы суффиксов и смещений, что ускоряет поиск и делает его более эффективным
* Лучшая сложность в среднем случае $O(n/m)$, где $n$ - длина строки, $m$ - длина подстроки

###### Недостатки:

* Реализация более сложная, чем у наивного алгоритма
* Некоторые таблицы могут быть большими и занимать много памяти

#### Алгоритм Кнута-Морриса-Пратта

Алгоритм Кнута-Морриса-Пратта использует префикс-функцию для поиска подстроки в строке. Префикс-функция для подстроки - это массив, содержащий значения наибольшей длины собственного префикса, который является также суффиксом этой подстроки. Алгоритм переходит от начала строки к концу, сравнивая символы подстроки с символами строки. Если символы не совпадают, алгоритм использует префикс-функцию, чтобы определить максимальное смещение и переходит на него. Если совпадение не найдено, алгоритм продолжает поиск.

###### Достоинства:

* Эффективен на длинных строках и подстроках
* Использует префикс-функцию, что делает поиск быстрым и эффективным
* Лучшая сложность в худшем случае $O(n+m)$, где $n$ - длина строки, $m$ - длина подстроки

###### Недостатки:

* Реализация более сложная, чем у наивного алгоритма
* Некоторые вычисления могут быть затратными, если длина подстроки очень большая

### Задание 2

Дан набор рефератов. Выберите любой алгоритм поиска и определите количество плагиата (в % от общего количества символов в реферате) в тексте реферата, взяв за основу соответствующие статьи из Википедии (название файла = название статьи). За плагиат считать любые 3 совпавших слова, идущих подряд. Обоснуйте выбранный алгоритм поиска.

#### Решение

```
Код
```

> Описание