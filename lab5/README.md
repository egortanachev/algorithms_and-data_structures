## Лабораторная работа №5

### Задание 1

Вор пробрался в музей и хочет украсть $N$ экспонатов. У каждого экспоната есть свой вес и цена. Вор может сделать $M$ заходов, каждый раз унося $K$ кг веса. Определить, что должен унести вор, чтобы сумма украденного была максимальной.

#### Решение

```
def stolen_items(items, M, K):
    # Сортируем экспонаты по их ценности
    sorted_items = sorted(items, key=lambda x: x[1], reverse=True)
    stolen_items = []
    total_value = 0

    # Проходимся по каждому экспонату, начиная с самого ценного
    for item in sorted_items:
        if item[0] <= K and M > 0:
            stolen_items.append(item)
            total_value += item[1]
            M -= 1

    return stolen_items, total_value

items = [(3, 50), (2, 30), (1, 20), (4, 60), (5, 70)]
M = 3
K = 5

stolen, value = stolen_items(items, M, K)

print("Украденные экспонаты: ", stolen)
print("Общая ценность украденных экспонатов: ", value)
```

> 1. Сортируем экспонаты по их ценности (от большей к меньшей).
> 2. Проходимся по каждому экспонату, начиная с самого ценного.
> 3. Если его вес не превышает оставшееся количество кг, которое может унести вор, то добавляем его в список украденных экспонатов и вычитаем его вес из оставшегося количества кг.
> 4. Если же его вес превышает оставшееся количество кг, то переходим к следующему экспонату.

### Задание 2

Дана последовательность матриц $A, B, C, … , Z$ таким образом, что с ними можно выполнить ассоциативные операции. Используя динамическое программирование, минимизируйте количество скалярных операций для нахождения их произведения.

#### Решение

```
import sys

def matrix_chain_order(p):
    n = len(p) - 1
    m = [[0] * (n + 1) for _ in range(n + 1)]
    s = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(1, n+1):
        m[i][i] = 0
    for l in range(2, n+1):
        for i in range(1, n-l+2):
            j = i + l - 1
            m[i][j] = sys.maxsize
            for k in range(i, j):
                q = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]
                if q < m[i][j]:
                    m[i][j] = q
                    s[i][j] = k
    return m[1][n], s

p = [10, 100, 5, 50, 1, 1000]
минимальное_кол-во_операций, оптимальное_разбиение = matrix_chain_order(p)
print("Минимальное количество скалярных операций:", минимальное_кол-во_операций)
print("Оптимальное разбиение:", оптимальное_разбиение)
```

> 1. Создаем таблицу $m$ размером $(n+1) x (n+1)$, где $n$ - это количество матриц в последовательности. $m[i][j]$ будет содержать минимальное количество скалярных операций, необходимых для умножения матриц от $A[i]$ до $A[j]$.
> 2. Заполняем таблицу $m$ по диагонали, начиная с $m[1][1]$, затем $m[2][2]$, $m[3][3]$, и т.д., пока не заполните $m[n][n]$. Для каждого элемента $m[i][j]$, где $i < j$, найти минимальное количество скалярных операций, необходимых для умножения матриц от $A[i]$ до $A[j]$. Для этого мы будем итерироваться по всем возможным разбиениям этого интервала на две подпоследовательности $A[i]...A[k]$ и $A[k+1]...A[j]$, где $i \leq k < j$, и для каждого такого разбиения мы вычисляем количество скалярных операций, необходимых для умножения двух соответствующих подматриц. Затем мы выбираем наименьшее значение из всех возможных разбиений и сохраняем его в $m[i][j]$.
> 3. Чтобы восстановить оптимальный путь умножения матриц, мы можем использовать таблицу $s$ размером $(n+1) x (n+1)$, где $s[i][j]$ содержит индекс $k$, который разделяет интервал $A[i]...A[j]$ на две подпоследовательности с минимальным количеством скалярных операций. Мы можем заполнить таблицу $s$ во время заполнения таблицы $m$. Затем мы можем рекурсивно обходить таблицу $s$, чтобы восстановить оптимальный путь умножения матриц.

### Задание 3

Дан массив $N$, состоящий из $n$ случайных целых чисел, находящихся в диапазоне от $-100$ до $100$. Найти наибольшую непрерывную возрастающую последовательность из чисел внутри массива (длину серии, для которой верно $N[i] < N[i+1] < N[i+2] < ... < N[i+m]$, где $i \geq 0$, а $i + m \leq n - 1$).

#### Решение

```
def find_longest_increasing_sequence(arr):
    longest_seq = []
    current_seq = []

    for i in range(len(arr)):
        if i == 0 or arr[i] <= arr[i-1]:
            current_seq = [arr[i]]
        else:
            current_seq.append(arr[i])

        if len(current_seq) > len(longest_seq):
            longest_seq = current_seq

    return longest_seq

arr = [1, 2, 3, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 7]
longest_seq = find_longest_increasing_sequence(arr)
print(longest_seq)
```

> 1. Инициализируем переменные longest_seq и current_seq как пустые списки.
> 2. Проходимся по элементам массива $arr$ с помощью цикла for.
> 3. Если текущий элемент $arr[i]$ меньше или равен предыдущему элементу $arr[i-1]$, то начинаем новую последовательность с текущего элемента. Иначе, добавляем текущий элемент в текущую последовательность.
> 4. Если длина текущей последовательности больше длины наибольшей последовательности, то обновляем наибольшую последовательность.
> 5. Возвращаем наибольшую последовательность.