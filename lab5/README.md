## Лабораторная работа №5

### Задание 1

Вор пробрался в музей и хочет украсть $N$ экспонатов. У каждого экспоната есть свой вес и цена. Вор может сделать $M$ заходов, каждый раз унося $K$ кг веса. Определить, что должен унести вор, чтобы сумма украденного была максимальной.

#### Решение

```
def get_max_values_one_attempt(items, K=7):
    N = len(items)
    max_values = [[0 for j in range(K+1)] for i in range(N+1)]

    for i in range(1, N+1):
        for j in range(1, K+1):
            if items[i-1][0] > j:
                max_values[i][j] = max_values[i-1][j]
            else:
                max_values[i][j] = max(max_values[i-1][j], max_values[i-1][j-items[i-1][0]] + items[i-1][1])

    stolen_items = []
    i = N
    j = K

    while i > 0 and j > 0:
        if max_values[i][j] != max_values[i-1][j]:
            stolen_items.append(i-1)
            j -= items[i-1][0]
        i -= 1

    return max_values[N][K], [items[i] for i in stolen_items]

def backpack_problem(items, K=7, M=2):
    result = []
    for _ in range(M):
        new_items = get_max_values_one_attempt(items, K)[1]
        if not len(new_items):
            break
        result.append(new_items)
        items = list(set(items).difference(set(new_items)))
    return result

def print_result(result):
    total_value = 0
    total_weight = 0
    attempts = 0
    for i, attempt in enumerate(result):
        weight = sum([i[0] for i in attempt])
        value = sum([i[1] for i in attempt])
        total_weight += weight
        total_value += value
        attempts += 1
    print(f"В общем украдено {total_weight}кг на {total_value} у. е. за {attempts} захода")

items = [(2, 1000), (3, 120), (5, 250), (6, 320), (10, 10000000)]
print_result(backpack_problem(items, 6, 10))
```

### Задание 2

Дана последовательность матриц $A, B, C, … , Z$ таким образом, что с ними можно выполнить ассоциативные операции. Используя динамическое программирование, минимизируйте количество скалярных операций для нахождения их произведения.

#### Решение

```
import sys

def matrix_chain_order(p):
    n = len(p) - 1
    m = [[0] * (n + 1) for _ in range(n + 1)]
    s = [[0] * (n + 1) for _ in range(n + 1)]
    for i in range(1, n+1):
        m[i][i] = 0
    for l in range(2, n+1):
        for i in range(1, n-l+2):
            j = i + l - 1
            m[i][j] = sys.maxsize
            for k in range(i, j):
                q = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j]
                if q < m[i][j]:
                    m[i][j] = q
                    s[i][j] = k
    return m[1][n], s

p = [10, 100, 5, 50, 1, 1000]
минимальное_кол-во_операций, оптимальное_разбиение = matrix_chain_order(p)
print("Минимальное количество скалярных операций:", минимальное_кол-во_операций)
print("Оптимальное разбиение:", оптимальное_разбиение)
```

> 1. Создаем таблицу $m$ размером $(n+1) x (n+1)$, где $n$ - это количество матриц в последовательности. $m[i][j]$ будет содержать минимальное количество скалярных операций, необходимых для умножения матриц от $A[i]$ до $A[j]$.
> 2. Заполняем таблицу $m$ по диагонали, начиная с $m[1][1]$, затем $m[2][2]$, $m[3][3]$, и т.д., пока не заполните $m[n][n]$. Для каждого элемента $m[i][j]$, где $i < j$, найти минимальное количество скалярных операций, необходимых для умножения матриц от $A[i]$ до $A[j]$. Для этого мы будем итерироваться по всем возможным разбиениям этого интервала на две подпоследовательности $A[i]...A[k]$ и $A[k+1]...A[j]$, где $i \leq k < j$, и для каждого такого разбиения мы вычисляем количество скалярных операций, необходимых для умножения двух соответствующих подматриц. Затем мы выбираем наименьшее значение из всех возможных разбиений и сохраняем его в $m[i][j]$.
> 3. Чтобы восстановить оптимальный путь умножения матриц, мы можем использовать таблицу $s$ размером $(n+1) x (n+1)$, где $s[i][j]$ содержит индекс $k$, который разделяет интервал $A[i]...A[j]$ на две подпоследовательности с минимальным количеством скалярных операций. Мы можем заполнить таблицу $s$ во время заполнения таблицы $m$. Затем мы можем рекурсивно обходить таблицу $s$, чтобы восстановить оптимальный путь умножения матриц.

### Задание 3

Дан массив $N$, состоящий из $n$ случайных целых чисел, находящихся в диапазоне от $-100$ до $100$. Найти наибольшую непрерывную возрастающую последовательность из чисел внутри массива (длину серии, для которой верно $N[i] < N[i+1] < N[i+2] < ... < N[i+m]$, где $i \geq 0$, а $i + m \leq n - 1$).

#### Решение

```
def find_longest_increasing_sequence(arr):
    longest_seq = []
    current_seq = []

    for i in range(len(arr)):
        if i == 0 or arr[i] <= arr[i-1]:
            current_seq = [arr[i]]
        else:
            current_seq.append(arr[i])

        if len(current_seq) > len(longest_seq):
            longest_seq = current_seq

    return longest_seq

arr = [1, 2, 3, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 7]
longest_seq = find_longest_increasing_sequence(arr)
print(longest_seq)
```

> 1. Инициализируем переменные longest_seq и current_seq как пустые списки.
> 2. Проходимся по элементам массива $arr$ с помощью цикла for.
> 3. Если текущий элемент $arr[i]$ меньше или равен предыдущему элементу $arr[i-1]$, то начинаем новую последовательность с текущего элемента. Иначе, добавляем текущий элемент в текущую последовательность.
> 4. Если длина текущей последовательности больше длины наибольшей последовательности, то обновляем наибольшую последовательность.
> 5. Возвращаем наибольшую последовательность.